Timer unit: 1e-09 s

Total time: 0.0116388 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: P528 at line 160

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   160                                           def P528(d__km: float, h_1__meter: float, h_2__meter: float, f__mhz: float,
   161                                                    T_pol: int, p: float):
   162         1       3378.0   3378.0      0.0      terminal_1 = Terminal()
   163         1       1472.0   1472.0      0.0      terminal_2 = Terminal()
   164         1       2158.0   2158.0      0.0      tropo = TroposcatterParams()
   165         1       1150.0   1150.0      0.0      path = Path()
   166         1       5037.0   5037.0      0.0      los_params = LineOfSightParams()
   167                                           
   168         1       1895.0   1895.0      0.0      result = Result()
   169         2   11623514.0    6e+06     99.9      return_value = P528_Ex(d__km, h_1__meter, h_2__meter, f__mhz, T_pol, p, result,
   170         1        171.0    171.0      0.0                             terminal_1, terminal_2, tropo, path, los_params)
   171                                           
   172         1         53.0     53.0      0.0      return return_value

Total time: 0.0116167 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: P528_Ex at line 174

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   174                                           def P528_Ex(d__km: float, h_1__meter: float, h_2__meter: float, f__mhz: float,
   175                                                       T_pol: int, p: float, result: Result, terminal_1: Terminal, terminal_2: Terminal,
   176                                                       tropo: TroposcatterParams, path: Path, los_params: LineOfSightParams) -> int:
   177                                               
   178                                               # reset Results struct
   179         1        311.0    311.0      0.0      result.A_fs__db = 0
   180         1        189.0    189.0      0.0      result.A_a__db = 0
   181         1        168.0    168.0      0.0      result.A__db = 0
   182         1        176.0    176.0      0.0      result.d__km = 0
   183         1        142.0    142.0      0.0      result.theta_h1__rad = 0
   184         1        237.0    237.0      0.0      result.propagation_mode = PROP_MODE__NOT_SET
   185                                           
   186         1       5985.0   5985.0      0.1      err = ValidateInputs(d__km, h_1__meter, h_2__meter, f__mhz, T_pol, p)
   187                                           
   188         1        253.0    253.0      0.0      result.result = err
   189                                               
   190         1        267.0    267.0      0.0      if err != 'SUCCESS':
   191                                                   if err == 'ERROR_HEIGHT_AND_DISTANCE':
   192                                                       result.A_fs__db = 0
   193                                                       result.A_a__db = 0
   194                                                       result.A__db = 0
   195                                                       result.d__km = 0
   196                                                       return result
   197                                                   else:
   198                                                       result.result = err
   199                                                       return result
   200                                           
   201                                               # Compute terminal geometries
   202                                               
   203                                               # Step 1 for low terminal
   204         1        564.0    564.0      0.0      terminal_1.h_r__km = h_1__meter / 1000
   205         1    4787603.0    5e+06     41.2      TerminalGeometry(f__mhz, terminal_1)
   206                                           
   207                                               # Step 1 for high terminal
   208         1        274.0    274.0      0.0      terminal_2.h_r__km = h_2__meter / 1000
   209         1    3911848.0    4e+06     33.7      TerminalGeometry(f__mhz, terminal_2)
   210                                           
   211                                               # Step 2
   212         1        281.0    281.0      0.0      path.d_ML__km = terminal_1.d_r__km + terminal_2.d_r__km  # [Eqn 3-1]
   213                                           
   214                                               # Smooth earth diffraction line calculations
   215                                           
   216                                               # Step 3.1
   217         1        469.0    469.0      0.0      d_3__km = path.d_ML__km + 0.5 * pow(pow(a_e__km, 2) / f__mhz, THIRD)  # [Eqn 3-2]
   218         1        397.0    397.0      0.0      d_4__km = path.d_ML__km + 1.5 * pow(pow(a_e__km, 2) / f__mhz, THIRD)  # [Eqn 3-3]
   219                                           
   220                                               # Step 3.2
   221         1      12558.0  12558.0      0.1      A_3__db = SmoothEarthDiffraction(terminal_1.d_r__km, terminal_2.d_r__km, f__mhz, d_3__km, T_pol)
   222         1       5233.0   5233.0      0.0      A_4__db = SmoothEarthDiffraction(terminal_1.d_r__km, terminal_2.d_r__km, f__mhz, d_4__km, T_pol)
   223                                           
   224                                               # Step 3.3
   225         1        192.0    192.0      0.0      M_d = (A_4__db - A_3__db) / (d_4__km - d_3__km)  # [Eqn 3-4]
   226         1        166.0    166.0      0.0      A_d0 = A_4__db - M_d * d_4__km  # [Eqn 3-5]
   227                                           
   228                                               # Step 3.4
   229         1        168.0    168.0      0.0      A_dML__db = (M_d * path.d_ML__km) + A_d0  # [Eqn 3-6]
   230         1        201.0    201.0      0.0      path.d_d__km = -(A_d0 / M_d)  # [Eqn 3-7]
   231                                           
   232         1        134.0    134.0      0.0      K_LOS = 0
   233                                           
   234                                               # Step 4. If the path is in the Line-of-Sight range, call LOS and then exit
   235         1        215.0    215.0      0.0      if path.d_ML__km - d__km > 0.001:
   236                                                   
   237         1        238.0    238.0      0.0          result.propagation_mode = PROP_MODE__LOS
   238         1    2888369.0    3e+06     24.9          K_LOS = LineOfSight(path, terminal_1, terminal_2, los_params, f__mhz, -A_dML__db, p, d__km, T_pol, result, K_LOS)        
   239         1         81.0     81.0      0.0          return result
   240                                               
   241                                               else:
   242                                                   
   243                                                   K_LOS = LineOfSight(path, terminal_1, terminal_2, los_params, f__mhz, -A_dML__db, p, path.d_ML__km - 1, T_pol, result, K_LOS)
   244                                           
   245                                                   # Step 6. Search past horizon to find crossover point between Diffraction and Troposcatter models
   246                                                                                   #TranshorizonSearch(path, terminal_1, terminal_2, f__mhz, A_dML__db, M_d, A_d0,Const)
   247                                                   M_d, A_d0, d_crx__km, CASE = TranshorizonSearch(path, terminal_1, terminal_2, f__mhz, A_dML__db, M_d, A_d0)
   248                                                   #[rtn, M_d, A_d0, d_crx__km, CASE]
   249                                                   
   250                                                   # Compute terrain attenuation, A_T__db
   251                                           
   252                                                   # Step 7.1
   253                                                   A_d__db = M_d * d__km + A_d0  # [Eqn 3-14]
   254                                           
   255                                                   # Step 7.2
   256                                                   troposcatter(path, terminal_1, terminal_2, d__km, f__mhz, tropo)
   257                                           
   258                                                   # Step 7.3
   259                                                   if d__km < d_crx__km:
   260                                                       # always in diffraction if less than d_crx
   261                                                       A_T__db = A_d__db
   262                                                       result.propagation_mode = PROP_MODE__DIFFRACTION
   263                                                   else:
   264                                                       if CASE == CASE_1:
   265                                                           # select the lower loss mode of propagation
   266                                                           if tropo.A_s__db <= A_d__db:
   267                                                               A_T__db = tropo.A_s__db
   268                                                               result.propagation_mode = PROP_MODE__SCATTERING
   269                                                           else:
   270                                                               A_T__db = A_d__db
   271                                                               result.propagation_mode = PROP_MODE__DIFFRACTION
   272                                                       else:  # CASE_2
   273                                                           A_T__db = tropo.A_s__db
   274                                                           result.propagation_mode = PROP_MODE__SCATTERING
   275                                           
   276                                                   # Compute variability
   277                                           
   278                                                   # f_theta_h is unity for transhorizon paths
   279                                                   f_theta_h = 1
   280                                           
   281                                                   # compute the 50% and p% of the long-term variability distribution
   282                                                   Y_e__db, _ = LongTermVariability(terminal_1.d_r__km, terminal_2.d_r__km, d__km, f__mhz, p, f_theta_h, -A_T__db)
   283                                                   Y_e_50__db, _ = LongTermVariability(terminal_1.d_r__km, terminal_2.d_r__km, d__km, f__mhz, 50, f_theta_h, -A_T__db)
   284                                                   
   285                                                   # compute the 50% and p% of the Nakagami-Rice distribution
   286                                                   ANGLE = 0.02617993878  # 1.5 deg
   287                                                   if tropo.theta_s >= ANGLE:  # theta_s > 1.5 deg
   288                                                       K_t__db = 20
   289                                                   elif tropo.theta_s <= 0.0:
   290                                                       K_t__db = K_LOS
   291                                                   else:
   292                                                       K_t__db = (tropo.theta_s * (20.0 - K_LOS) / ANGLE) + K_LOS
   293                                           
   294                                                   Y_pi_50__db = 0.0  # zero mean
   295                                                   Y_pi__db = NakagamiRice(K_t__db, p)
   296                                           
   297                                                   # combine the long-term and Nakagami-Rice distributions
   298                                                   Y_total__db = CombineDistributions(Y_e_50__db, Y_e__db, Y_pi_50__db, Y_pi__db, p)        
   299                                                   
   300                                                   # Atmospheric absorption for transhorizon path
   301                                           
   302                                                   result_v = SlantPathAttenuation(f__mhz / 1000, 0, tropo.h_v__km, pi / 2)
   303                                           
   304                                                   result.A_a__db = terminal_1.A_a__db + terminal_2.A_a__db + 2 * result_v.A_gas__db  # [Eqn 3-17]
   305                                           
   306                                                   # Compute free-space loss
   307                                           
   308                                                   r_fs__km = terminal_1.a__km + terminal_2.a__km + 2 * result_v.a__km  # [Eqn 3-18]
   309                                                   result.A_fs__db = 20.0 * math.log10(f__mhz) + 20.0 * math.log10(r_fs__km) + 32.45  # [Eqn 3-19]
   310                                           
   311                                                   result.d__km = d__km
   312                                                   result.A__db = result.A_fs__db + result.A_a__db + A_T__db - Y_total__db  # [Eqn 3-20]
   313                                                   result.theta_h1__rad = -terminal_1.theta__rad
   314                                                   
   315                                                   return result

Total time: 2.386e-06 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: ValidateInputs at line 317

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   317                                           def ValidateInputs(d_km, h_1_meter, h_2_meter, f_mhz, t_pol, p):
   318                                               
   319                                               #np where d_km[i]<0: Raise ValueError i
   320         1        329.0    329.0     13.8      if d_km < 0:
   321                                                   return "ERROR_VALIDATION__D_KM"
   322                                           
   323         1        553.0    553.0     23.2      if h_1_meter < 1.5 or h_1_meter > 20000:
   324                                                   return "ERROR_VALIDATION__H_1"
   325                                           
   326         1        212.0    212.0      8.9      if h_2_meter < 1.5 or h_2_meter > 20000:
   327                                                   return "ERROR_VALIDATION__H_2"
   328                                           
   329         1        150.0    150.0      6.3      if h_1_meter > h_2_meter:
   330                                                   return "ERROR_VALIDATION__TERM_GEO"
   331                                           
   332         1        153.0    153.0      6.4      if f_mhz < 100:
   333                                                   return "ERROR_VALIDATION__F_MHZ_LOW"
   334                                           
   335         1        161.0    161.0      6.7      if f_mhz > 30000:
   336                                                   return "ERROR_VALIDATION__F_MHZ_HIGH"
   337                                           
   338         1        205.0    205.0      8.6      if t_pol != POLARIZATION__HORIZONTAL and t_pol != POLARIZATION__VERTICAL:
   339                                                   return "ERROR_VALIDATION__POLARIZATION"
   340                                           
   341         1        163.0    163.0      6.8      if p < 1:
   342                                                   return "ERROR_VALIDATION__PERCENT_LOW"
   343                                           
   344         1        172.0    172.0      7.2      if p > 99:
   345                                                   return "ERROR_VALIDATION__PERCENT_HIGH"
   346                                           
   347         1        157.0    157.0      6.6      if h_1_meter == h_2_meter and d_km == 0:
   348                                                   return "ERROR_HEIGHT_AND_DISTANCE"
   349                                           
   350         1        131.0    131.0      5.5      return "SUCCESS"

Total time: 0.00869206 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: TerminalGeometry at line 352

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   352                                           def TerminalGeometry(f__mhz: float, terminal: Terminal) -> None:
   353         2        340.0    170.0      0.0      theta_tx__rad = 0
   354         2    8686219.0    4e+06     99.9      result = SlantPathAttenuation(f__mhz / 1000, 0, terminal.h_r__km, pi / 2 - theta_tx__rad)
   355                                               
   356         2       1305.0    652.5      0.0      terminal.theta__rad = pi / 2 - result.angle__rad
   357         2        436.0    218.0      0.0      terminal.A_a__db = result.A_gas__db
   358         2        372.0    186.0      0.0      terminal.a__km = result.a__km
   359                                               
   360                                               # compute arc distance
   361         2        651.0    325.5      0.0      central_angle = ((pi / 2 - result.angle__rad) - theta_tx__rad + result.bending__rad)
   362         2        406.0    203.0      0.0      terminal.d_r__km = a_0__km * central_angle
   363         2        535.0    267.5      0.0      terminal.phi__rad = terminal.d_r__km / a_e__km
   364         2        939.0    469.5      0.0      terminal.h_e__km = (a_e__km / math.cos(terminal.phi__rad)) - a_e__km
   365         2        859.0    429.5      0.0      terminal.delta_h__km = terminal.h_r__km - terminal.h_e__km

Total time: 1.3578e-05 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: SmoothEarthDiffraction at line 1050

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1050                                           def SmoothEarthDiffraction(d_1__km: float, d_2__km: float, f__mhz: float, d_0__km: float, T_pol: int) -> float:
  1051                                               """
  1052                                               Calculate the smooth earth diffraction loss.
  1053                                           
  1054                                               Args:
  1055                                               d_1__km (float): Horizon distance of terminal 1, in km
  1056                                               d_2__km (float): Horizon distance of terminal 2, in km
  1057                                               f__mhz (float): Frequency, in MHz
  1058                                               d_0__km (float): Path length of interest, in km
  1059                                               T_pol (int): Polarization code (0 for horizontal, 1 for vertical)
  1060                                           
  1061                                               Returns:
  1062                                               float: Diffraction loss in dB
  1063                                               """
  1064         2        191.0     95.5      1.4      THIRD = 1/3
  1065         2        485.0    242.5      3.6      s = 18000 * sigma / f__mhz
  1066                                           
  1067         2        352.0    176.0      2.6      if T_pol == POLARIZATION__HORIZONTAL:
  1068         2       1401.0    700.5     10.3          K = 0.01778 * math.pow(f__mhz, -THIRD) * math.pow(math.pow(epsilon_r - 1, 2) + math.pow(s, 2), -0.25)
  1069                                               else:
  1070                                                   K = 0.01778 * math.pow(f__mhz, -THIRD) * math.pow((math.pow(epsilon_r, 2) + math.pow(s, 2)) / math.pow(math.pow(epsilon_r - 1, 2) + math.pow(s, 2), 0.5), 0.5)
  1071                                           
  1072         2        167.0     83.5      1.2      B_0 = 1.607
  1073                                           
  1074                                               # [Vogler 1964, Equ 2] with C_0 = 1 due to "4/3" Earth assumption
  1075         2        577.0    288.5      4.2      x_0__km = (B_0 - K) * math.pow(f__mhz, THIRD) * d_0__km
  1076         2        356.0    178.0      2.6      x_1__km = (B_0 - K) * math.pow(f__mhz, THIRD) * d_1__km
  1077         2        321.0    160.5      2.4      x_2__km = (B_0 - K) * math.pow(f__mhz, THIRD) * d_2__km
  1078                                           
  1079                                               # Compute the distance function for the path
  1080         2       2652.0   1326.0     19.5      G_x__db = DistanceFunction(x_0__km)
  1081                                           
  1082                                               # Compute the height functions for the two terminals
  1083         2       5108.0   2554.0     37.6      F_x1__db = HeightFunction(x_1__km, K)
  1084         2       1660.0    830.0     12.2      F_x2__db = HeightFunction(x_2__km, K)
  1085                                           
  1086                                               # [Vogler 1964, Equ 1] with C_1(K, b^0) = 20, which is the approximate value for all K (see Figure 5)
  1087         2        308.0    154.0      2.3      return G_x__db - F_x1__db - F_x2__db - 20.0

Total time: 0.000693709 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: FindPsiAtDistance at line 1089

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1089                                           def FindPsiAtDistance(d__km: float, path: Path, terminal_1: Terminal, terminal_2: Terminal) -> float:
  1090         4        457.0    114.2      0.1      if d__km == 0:
  1091         1        159.0    159.0      0.0          return math.pi / 2
  1092                                           
  1093                                               # initialize to start at mid-point
  1094         3        575.0    191.7      0.1      psi = math.pi / 2
  1095         3        503.0    167.7      0.1      delta_psi = -math.pi / 4
  1096                                           
  1097        63       5333.0     84.7      0.8      while True:
  1098        63       5751.0     91.3      0.8          psi += delta_psi  # new psi
  1099                                           
  1100        63      71766.0   1139.1     10.3          params_temp = LineOfSightParams()
  1101        63     567584.0   9009.3     81.8          RayOptics(terminal_1, terminal_2, psi, params_temp)
  1102                                           
  1103        63       7193.0    114.2      1.0          d_psi__km = params_temp.d__km
  1104                                           
  1105                                                   # compute delta
  1106        63       6459.0    102.5      0.9          if d_psi__km > d__km:
  1107        14       2141.0    152.9      0.3              delta_psi = abs(delta_psi) / 2
  1108                                                   else:
  1109        49       7556.0    154.2      1.1              delta_psi = -abs(delta_psi) / 2
  1110                                           
  1111        63      17759.0    281.9      2.6          if abs(d__km - d_psi__km) <= 1e-3 or abs(delta_psi) <= 1e-12:
  1112         3        216.0     72.0      0.0              break
  1113                                           
  1114         3        257.0     85.7      0.0      return psi

Total time: 0.000251791 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: FindPsiAtDeltaR at line 1116

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1116                                           def FindPsiAtDeltaR(delta_r__km: float, path: Path, terminal_1: Terminal, terminal_2: Terminal, terminate: float) -> float:
  1117         1        434.0    434.0      0.2      psi = math.pi / 2
  1118         1        198.0    198.0      0.1      delta_psi = -math.pi / 4
  1119                                           
  1120        23       1736.0     75.5      0.7      while True:
  1121        23       1967.0     85.5      0.8          psi += delta_psi
  1122                                           
  1123        23      28283.0   1229.7     11.2          params_temp = LineOfSightParams()
  1124                                                   
  1125        23     209463.0   9107.1     83.2          RayOptics(terminal_1, terminal_2, psi, params_temp)
  1126                                           
  1127        23       2567.0    111.6      1.0          if params_temp.delta_r__km > delta_r__km:
  1128        12       1874.0    156.2      0.7              delta_psi = -abs(delta_psi) / 2
  1129                                                   else:
  1130        11       1511.0    137.4      0.6              delta_psi = abs(delta_psi) / 2
  1131                                           
  1132        23       3610.0    157.0      1.4          if abs(params_temp.delta_r__km - delta_r__km) <= terminate:
  1133         1         77.0     77.0      0.0              break
  1134                                           
  1135                                           
  1136         1         71.0     71.0      0.0      return psi

Total time: 0.000237801 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: FindDistanceAtDeltaR at line 1138

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1138                                           def FindDistanceAtDeltaR(delta_r__km: float, path: Path, terminal_1: Terminal, terminal_2: Terminal, terminate: float) -> float:
  1139         1        184.0    184.0      0.1      psi = math.pi / 2
  1140         1        161.0    161.0      0.1      delta_psi = -math.pi / 4
  1141                                           
  1142        23       1720.0     74.8      0.7      while True:
  1143        23       2083.0     90.6      0.9          psi += delta_psi
  1144                                           
  1145        23      25418.0   1105.1     10.7          params_temp = LineOfSightParams()
  1146        23     197980.0   8607.8     83.3          RayOptics(terminal_1, terminal_2, psi, params_temp)
  1147                                           
  1148        23       2649.0    115.2      1.1          if params_temp.delta_r__km > delta_r__km:
  1149        15       2692.0    179.5      1.1              delta_psi = -abs(delta_psi) / 2
  1150                                                   else:
  1151         8       1254.0    156.8      0.5              delta_psi = abs(delta_psi) / 2
  1152                                           
  1153        23       3497.0    152.0      1.5          if abs(params_temp.delta_r__km - delta_r__km) <= terminate:
  1154         1         64.0     64.0      0.0              break
  1155                                           
  1156         1         99.0     99.0      0.0      return params_temp.d__km

Total time: 0.00287536 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: LineOfSight at line 1158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1158                                           def LineOfSight(path: Path, terminal_1: Terminal, terminal_2: Terminal, los_params: LineOfSightParams,
  1159                                                           f__mhz: float, A_dML__db: float, p: float, d__km: float, T_pol: int, result: Result, K_LOS: float) -> float:
  1160                                           
  1161                                               # 0.2997925 = speed of light, gigameters per sec
  1162         1        126.0    126.0      0.0      lambda__km = 0.2997925 / f__mhz  # [Eqn 6-1]
  1163         1        157.0    157.0      0.0      terminate = lambda__km / 1e6
  1164                                           
  1165                                               # determine psi_limit, where you switch from free space to 2-ray model
  1166                                               # lambda / 2 is the start of the lobe closest to d_ML
  1167         1     269345.0 269345.0      9.4      psi_limit = FindPsiAtDeltaR(lambda__km / 2, path, terminal_1, terminal_2, terminate)
  1168                                               
  1169                                               # "[d_y6__km] is the largest distance at which a free-space value is obtained in a two-ray model
  1170                                               #   of reflection from a smooth earth with a reflection coefficient of -1" [ES-83-3, page 44]
  1171         1     253750.0 253750.0      8.8      d_y6__km = FindDistanceAtDeltaR(lambda__km / 6, path, terminal_1, terminal_2, terminate)
  1172                                               
  1173                                               # Determine d_0__km distance
  1174         1        235.0    235.0      0.0      if terminal_1.d_r__km >= path.d_d__km or path.d_d__km >= path.d_ML__km:
  1175         1        149.0    149.0      0.0          if terminal_1.d_r__km > d_y6__km or d_y6__km > path.d_ML__km:
  1176         1        204.0    204.0      0.0              path.d_0__km = terminal_1.d_r__km
  1177                                                   else:
  1178                                                       path.d_0__km = d_y6__km
  1179                                               elif path.d_d__km < d_y6__km and d_y6__km < path.d_ML__km:
  1180                                                   path.d_0__km = d_y6__km
  1181                                               else:
  1182                                                   path.d_0__km = path.d_d__km
  1183                                           
  1184                                                   
  1185                                               # Tune d_0__km distance
  1186         1         91.0     91.0      0.0      d_temp__km = path.d_0__km
  1187                                                   
  1188         1       1108.0   1108.0      0.0      los_result = LineOfSightParams()
  1189                                               
  1190         2        170.0     85.0      0.0      while True:
  1191         2     470775.0 235387.5     16.4          psi = FindPsiAtDistance(d_temp__km, path, terminal_1, terminal_2)
  1192                                           
  1193                                           
  1194         2      17243.0   8621.5      0.6          los_result = RayOptics(terminal_1, terminal_2, psi, los_result)
  1195                                           
  1196         2        502.0    251.0      0.0          if los_result.d__km >= path.d_0__km or (d_temp__km + 0.001) >= path.d_ML__km:
  1197         1        127.0    127.0      0.0              path.d_0__km = los_result.d__km
  1198         1        111.0    111.0      0.0              break
  1199                                           
  1200         1        116.0    116.0      0.0          d_temp__km += 0.001
  1201                                           
  1202                                               # Compute loss at d_0__km
  1203         1     273045.0 273045.0      9.5      psi_d0 = FindPsiAtDistance(path.d_0__km, path, terminal_1, terminal_2)
  1204         1       8604.0   8604.0      0.3      RayOptics(terminal_1, terminal_2, psi_d0, los_params)
  1205         1      20863.0  20863.0      0.7      R_Tg = GetPathLoss(psi_d0, path, f__mhz, psi_limit, A_dML__db, 0, T_pol, los_params)
  1206                                           
  1207                                               # tune psi for the desired distance
  1208         1        950.0    950.0      0.0      psi = FindPsiAtDistance(d__km, path, terminal_1, terminal_2)
  1209         1      11074.0  11074.0      0.4      RayOptics(terminal_1, terminal_2, psi, los_params)
  1210         1      11538.0  11538.0      0.4      R_Tg = GetPathLoss(psi, path, f__mhz, psi_limit, A_dML__db, los_params.A_LOS__db, T_pol, los_params)
  1211                                               
  1212                                               # Compute atmospheric absorption
  1213         1    1484922.0    1e+06     51.6      result_slant = SlantPathAttenuation(f__mhz / 1000, terminal_1.h_r__km, terminal_2.h_r__km, math.pi / 2 - los_params.theta_h1__rad)
  1214         1        485.0    485.0      0.0      result.A_a__db = result_slant.A_gas__db
  1215                                           
  1216                                               # Compute free-space loss
  1217         1        862.0    862.0      0.0      result.A_fs__db = 20.0 * math.log10(los_params.r_0__km) + 20.0 * math.log10(f__mhz) + 32.45  # [Eqn 6-4]
  1218                                               
  1219                                               # Compute variability
  1220         2        522.0    261.0      0.0      f_theta_h = 1.0 if los_params.theta_h1__rad <= 0.0 else (
  1221         1        197.0    197.0      0.0          0.0 if los_params.theta_h1__rad >= 1.0 else
  1222                                                   max(0.5 - (1 / math.pi) * (math.atan(20.0 * math.log10(32.0 * los_params.theta_h1__rad))), 0)
  1223                                               )
  1224                                           
  1225         1      19535.0  19535.0      0.7      Y_e__db, A_Y = LongTermVariability(terminal_1.d_r__km, terminal_2.d_r__km, d__km, f__mhz, p, f_theta_h, los_params.A_LOS__db)
  1226         1      10468.0  10468.0      0.4      Y_e_50__db, _ = LongTermVariability(terminal_1.d_r__km, terminal_2.d_r__km, d__km, f__mhz, 50, f_theta_h, los_params.A_LOS__db)
  1227                                           
  1228         1        204.0    204.0      0.0      F_AY = 1.0 if A_Y <= 0.0 else (0.1 if A_Y >= 9.0 else (1.1 + (0.9 * math.cos((A_Y / 9.0) * math.pi))) / 2.0)
  1229                                           
  1230         1        330.0    330.0      0.0      F_delta_r = 1.0 if los_params.delta_r__km >= (lambda__km / 2.0) else (
  1231                                                   0.1 if los_params.delta_r__km <= lambda__km / 6.0 else
  1232                                                   0.5 * (1.1 - (0.9 * math.cos(((3.0 * math.pi) / lambda__km) * (los_params.delta_r__km - (lambda__km / 6.0)))))
  1233                                               )
  1234                                           
  1235         1        160.0    160.0      0.0      R_s = R_Tg * F_delta_r * F_AY  # [Eqn 13-4]
  1236                                           
  1237         1        473.0    473.0      0.0      Y_pi_99__db = 10.0 * math.log10(f__mhz * pow(result_slant.a__km, 3)) - 84.26  # [Eqn 13-5]
  1238         1       1561.0   1561.0      0.1      K_t = FindKForYpiAt99Percent(Y_pi_99__db)
  1239                                           
  1240         1        264.0    264.0      0.0      W_a = pow(10.0, K_t / 10.0)  # [Eqn 13-6]
  1241         1        290.0    290.0      0.0      W_R = pow(R_s, 2) + pow(0.01, 2)  # [Eqn 13-7]
  1242         1        227.0    227.0      0.0      W = W_R + W_a  # [Eqn 13-8]
  1243                                           
  1244         1        466.0    466.0      0.0      K_LOS = -40.0 if W <= 0.0 else max(10.0 * math.log10(W), -40.0)
  1245                                           
  1246         1         83.0     83.0      0.0      Y_pi_50__db = 0.0  # zero mean
  1247         1      10943.0  10943.0      0.4      Y_pi__db = NakagamiRice(K_LOS, p)
  1248                                           
  1249         1       2308.0   2308.0      0.1      Y_total__db = -CombineDistributions(Y_e_50__db, Y_e__db, Y_pi_50__db, Y_pi__db, p)
  1250                                           
  1251         1        165.0    165.0      0.0      result.d__km = los_params.d__km
  1252         1        404.0    404.0      0.0      result.A__db = result.A_fs__db + result.A_a__db - los_params.A_LOS__db + Y_total__db
  1253         1        125.0    125.0      0.0      result.theta_h1__rad = los_params.theta_h1__rad
  1254                                           
  1255         1         80.0     80.0      0.0      return K_LOS

Total time: 0.000617287 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: RayOptics at line 1257

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1257                                           def RayOptics(terminal_1: Terminal, terminal_2: Terminal, psi: float, params: LineOfSightParams) -> None:
  1258                                               
  1259       113      12570.0    111.2      2.0      z = (a_0__km / a_e__km) - 1       # [Eqn 7-1]
  1260       113      23862.0    211.2      3.9      k_a = 1 / (1 + z * math.cos(psi))      # [Eqn 7-2]
  1261       113      14293.0    126.5      2.3      params.a_a__km = a_0__km * k_a          # [Eqn 7-3]
  1262                                           
  1263       113      21772.0    192.7      3.5      delta_h_a1__km = terminal_1.delta_h__km * (params.a_a__km - a_0__km) / (a_e__km - a_0__km)  # [Eqn 7-4]
  1264       113      19093.0    169.0      3.1      delta_h_a2__km = terminal_2.delta_h__km * (params.a_a__km - a_0__km) / (a_e__km - a_0__km)  # [Eqn 7-4]
  1265                                                   
  1266       113      11293.0     99.9      1.8      H__km = [0, 0]
  1267       113      16846.0    149.1      2.7      H__km[0] = terminal_1.h_r__km - delta_h_a1__km    # [Eqn 7-5]
  1268       113      12414.0    109.9      2.0      H__km[1] = terminal_2.h_r__km - delta_h_a2__km    # [Eqn 7-5]
  1269                                               
  1270       113      12480.0    110.4      2.0      Hprime__km = [0, 0]
  1271       339      37080.0    109.4      6.0      for i in range(2):
  1272       226      34063.0    150.7      5.5          params.z__km[i] = params.a_a__km + H__km[i]                                  # [Eqn 7-6]
  1273       226      64550.0    285.6     10.5          params.theta[i] = math.acos(params.a_a__km * math.cos(psi) / params.z__km[i]) - psi   # [Eqn 7-7]
  1274       226      47014.0    208.0      7.6          params.D__km[i] = params.z__km[i] * math.sin(params.theta[i])                    # [Eqn 7-8]
  1275                                           
  1276                                                   # [Eqn 7-9]
  1277       226      20680.0     91.5      3.4          if psi > 1.56:
  1278         2        353.0    176.5      0.1              Hprime__km[i] = H__km[i]
  1279                                                   else:
  1280       224      43071.0    192.3      7.0              Hprime__km[i] = params.D__km[i] * math.tan(psi)
  1281                                           
  1282       113      20304.0    179.7      3.3      delta_z = abs(params.z__km[0] - params.z__km[1])   # [Eqn 7-10]
  1283                                           
  1284       113      32786.0    290.1      5.3      params.d__km = max(params.a_a__km * (params.theta[0] + params.theta[1]), 0)  # [Eqn 7-11]
  1285                                           
  1286       113      18664.0    165.2      3.0      if (params.D__km[0] + params.D__km[1]) != 0:
  1287       112      29244.0    261.1      4.7          alpha = math.atan((Hprime__km[1] - Hprime__km[0]) / (params.D__km[0] + params.D__km[1]))  # [Eqn 7-12]
  1288                                               else:
  1289         1        326.0    326.0      0.1          alpha = math.atan(math.inf)  # [Eqn 7-12]
  1290                                                   
  1291       113      33819.0    299.3      5.5      params.r_0__km = max(delta_z, (params.D__km[0] + params.D__km[1]) / math.cos(alpha))            # [Eqn 7-13]
  1292       113      26576.0    235.2      4.3      params.r_12__km = (params.D__km[0] + params.D__km[1]) / math.cos(psi)                           # [Eqn 7-14]
  1293                                           
  1294       113      25351.0    224.3      4.1      params.delta_r__km = 4.0 * Hprime__km[0] * Hprime__km[1] / (params.r_0__km + params.r_12__km)  # [Eqn 7-15]
  1295                                           
  1296       113      15385.0    136.2      2.5      params.theta_h1__rad = alpha - params.theta[0]                # [Eqn 7-16]
  1297       113      15821.0    140.0      2.6      params.theta_h2__rad = -(alpha + params.theta[1])             # [Eqn 7-17]
  1298                                           
  1299       113       7577.0     67.1      1.2      return params

Total time: 2.6067e-05 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: GetPathLoss at line 1301

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1301                                           def GetPathLoss(psi__rad: float, path: Path, f__mhz: float, psi_limit: float, 
  1302                                                           A_dML__db: float, A_d_0__db: float, T_pol: int, 
  1303                                                           params: LineOfSightParams) -> float:
  1304         2      16921.0   8460.5     64.9      R_g, phi_g = ReflectionCoefficients(psi__rad, f__mhz, T_pol)
  1305                                           
  1306         2        570.0    285.0      2.2      if math.tan(psi__rad) >= 0.1:
  1307         1        132.0    132.0      0.5          D_v = 1.0
  1308                                               else:
  1309         1        233.0    233.0      0.9          r_1 = params.D__km[0] / math.cos(psi__rad)       # [Eqn 8-3]
  1310         1        211.0    211.0      0.8          r_2 = params.D__km[1] / math.cos(psi__rad)       # [Eqn 8-3]
  1311         1        189.0    189.0      0.7          R_r = (r_1 * r_2) / params.r_12__km    # [Eqn 8-4]
  1312                                           
  1313         1        609.0    609.0      2.3          term_1 = (2 * R_r * (1 + math.sin(psi__rad)**2)) / (params.a_a__km * math.sin(psi__rad))
  1314         1        217.0    217.0      0.8          term_2 = (2 * R_r / params.a_a__km)**2
  1315         1        194.0    194.0      0.7          D_v = (1.0 + term_1 + term_2)**(-0.5)         # [Eqn 8-5]
  1316                                           
  1317                                               # Ray-length factor, [Eqn 8-6]
  1318         2        378.0    189.0      1.5      if (params.r_12__km != 0):
  1319         1        440.0    440.0      1.7          F_r = min(params.r_0__km / params.r_12__km, 1)
  1320                                               else:
  1321         1        344.0    344.0      1.3          F_r = min(math.inf, 1)
  1322                                           
  1323         2        315.0    157.5      1.2      R_Tg = R_g * D_v * F_r                            # [Eqn 8-7]
  1324                                           
  1325         2        380.0    190.0      1.5      if params.d__km > path.d_0__km:
  1326                                                   # [Eqn 8-1]
  1327                                                   params.A_LOS__db = ((params.d__km - path.d_0__km) * (A_dML__db - A_d_0__db) / (path.d_ML__km - path.d_0__km)) + A_d_0__db
  1328                                               else:
  1329         2        241.0    120.5      0.9          lambda__km = 0.2997925 / f__mhz	# [Eqn 8-2]
  1330                                           
  1331         2        215.0    107.5      0.8          if psi__rad > psi_limit:
  1332                                                       # ignore the phase lag; Step 8-2
  1333         1        123.0    123.0      0.5              params.A_LOS__db = 0
  1334                                                   else:
  1335                                                       # Total phase lag of the ground reflected ray relative to the direct ray
  1336                                           
  1337                                                       # [Eqn 8-8]
  1338         1        331.0    331.0      1.3              phi_Tg = (2 * math.pi * params.delta_r__km / lambda__km) + phi_g
  1339                                           
  1340                                                       # [Eqn 8-9]
  1341         1       1830.0   1830.0      7.0              cplx = complex(R_Tg * math.cos(phi_Tg), -R_Tg * math.sin(phi_Tg))
  1342                                           
  1343                                                       # [Eqn 8-10]
  1344         1       1562.0   1562.0      6.0              W_RL = min(abs(1.0 + cplx), 1.0)
  1345                                           
  1346                                                       # [Eqn 8-11]
  1347         1        126.0    126.0      0.5              W_R0 = W_RL**2
  1348                                           
  1349                                                       # [Eqn 8-12]
  1350         1        300.0    300.0      1.2              params.A_LOS__db = 10.0 * math.log10(W_R0)
  1351                                           
  1352         2        206.0    103.0      0.8      return R_Tg

Total time: 9.397e-06 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: ReflectionCoefficients at line 1354

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1354                                           def ReflectionCoefficients(psi__rad: float, f__mhz: float, T_pol: int):
  1355         2        357.0    178.5      3.8      if psi__rad <= 0.0:
  1356                                                   psi__rad = 0.0
  1357                                                   sin_psi = 0.0
  1358                                                   cos_psi = 1.0
  1359         2        681.0    340.5      7.2      elif psi__rad >= math.pi / 2:
  1360         1        153.0    153.0      1.6          psi__rad = math.pi / 2
  1361         1         77.0     77.0      0.8          sin_psi = 1.0
  1362         1        105.0    105.0      1.1          cos_psi = 0.0
  1363                                               else:
  1364         1        235.0    235.0      2.5          sin_psi = math.sin(psi__rad)
  1365         1        171.0    171.0      1.8          cos_psi = math.cos(psi__rad)
  1366                                           
  1367         2        369.0    184.5      3.9      X = (18000.0 * sigma) / f__mhz              # [Eqn 9-1]
  1368         2        817.0    408.5      8.7      Y = epsilon_r - cos_psi**2               # [Eqn 9-2]
  1369         2        686.0    343.0      7.3      T = math.sqrt(Y**2 + X**2) + Y         # [Eqn 9-3]
  1370         2        350.0    175.0      3.7      P = math.sqrt(T * 0.5)                           # [Eqn 9-4]
  1371         2        315.0    157.5      3.4      Q = X / (2.0 * P)                           # [Eqn 9-5]
  1372                                           
  1373                                               # [Eqn 9-6]
  1374         2        244.0    122.0      2.6      if T_pol == POLARIZATION__HORIZONTAL:
  1375         2        479.0    239.5      5.1          B = 1.0 / (P**2 + Q**2)
  1376                                               else:
  1377                                                   B = (epsilon_r**2 + X**2) / (P**2 + Q**2)
  1378                                           
  1379                                               # [Eqn 9-7]
  1380         2        198.0     99.0      2.1      if T_pol == POLARIZATION__HORIZONTAL:
  1381         2        483.0    241.5      5.1          A = (2.0 * P) / (P**2 + Q**2)
  1382                                               else:
  1383                                                   A = (2.0 * (P * epsilon_r + Q * X)) / (P**2 + Q**2)
  1384                                           
  1385                                               # [Eqn 9-8]
  1386         2        902.0    451.0      9.6      R_g = math.sqrt((1.0 + (B * sin_psi**2) - (A * sin_psi)) / (1.0 + (B * sin_psi**2) + (A * sin_psi)))
  1387                                           
  1388                                               # [Eqn 9-9]
  1389         2        205.0    102.5      2.2      if T_pol == POLARIZATION__HORIZONTAL:
  1390         2       1331.0    665.5     14.2          alpha = math.atan2(-Q, sin_psi - P)
  1391                                               else:
  1392                                                   alpha = math.atan2((epsilon_r * sin_psi) - Q, epsilon_r * sin_psi - P)
  1393                                           
  1394                                               # [Eqn 9-10]
  1395         2        246.0    123.0      2.6      if T_pol == POLARIZATION__HORIZONTAL:
  1396         2        490.0    245.0      5.2          beta = math.atan2(Q, sin_psi + P)
  1397                                               else:
  1398                                                   beta = math.atan2((X * sin_psi) + Q, epsilon_r * sin_psi + P)
  1399                                           
  1400                                               # [Eqn 9-11]
  1401         2        226.0    113.0      2.4      phi_g = alpha - beta
  1402                                           
  1403         2        277.0    138.5      2.9      return R_g, phi_g

Total time: 1.5018e-05 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: LongTermVariability at line 1408

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1408                                           def LongTermVariability(d_r1__km: float, d_r2__km: float, d__km: float, f__mhz: float,
  1409                                                                   p: float, f_theta_h: float, A_T: float):
  1410                                               """
  1411                                               Compute the long term variability as described in Annex 2, Section 14 of
  1412                                               Recommendation ITU-R P.528-5, "Propagation curves for aeronautical mobile
  1413                                               and radionavigation services using the VHF, UHF and SHF bands"
  1414                                           
  1415                                               Args:
  1416                                               d_r1__km (float): Actual height of low terminal, in km
  1417                                               d_r2__km (float): Actual height of high terminal, in km
  1418                                               d__km (float): Path distance, in km
  1419                                               f__mhz (float): Frequency, in MHz
  1420                                               p (float): Time percentage
  1421                                               f_theta_h (float): Angular distance factor
  1422                                               A_T (float): Total loss
  1423                                           
  1424                                               Returns:
  1425                                               tuple[float, float]: (Y_e__db, A_Y)
  1426                                                   Y_e__db: Variability, in dB
  1427                                                   A_Y: Conditional adjustment factor, in dB
  1428                                               """
  1429         2        214.0    107.0      1.4      THIRD = 1/3
  1430         2        525.0    262.5      3.5      d_qs__km = 65.0 * pow((100.0 / f__mhz), THIRD)  # [Eqn 14-1]
  1431         2        215.0    107.5      1.4      d_Lq__km = d_r1__km + d_r2__km  # [Eqn 14-2]
  1432         2        161.0     80.5      1.1      d_q__km = d_Lq__km + d_qs__km  # [Eqn 14-3]
  1433                                           
  1434                                               # [Eqn 14-4]
  1435         2        296.0    148.0      2.0      if d__km <= d_q__km:
  1436         2        367.0    183.5      2.4          d_e__km = (130.0 * d__km) / d_q__km
  1437                                               else:
  1438                                                   d_e__km = 130.0 + d__km - d_q__km
  1439                                           
  1440                                               # [Eqns 14-5 and 14-6]
  1441         2        301.0    150.5      2.0      if f__mhz > 1600.0:
  1442                                                   g_10 = g_90 = 1.05
  1443                                               else:
  1444         2        876.0    438.0      5.8          g_10 = (0.21 * math.sin(5.22 * math.log10(f__mhz / 200.0))) + 1.28
  1445         2        461.0    230.5      3.1          g_90 = (0.18 * math.sin(5.22 * math.log10(f__mhz / 200.0))) + 1.23
  1446                                           
  1447                                               # Data Source for Below Consts: Tech Note 101, Vol 2
  1448                                               # Column 1: Table III.4, Row A* (Page III-50)
  1449                                               # Column 2: Table III.3, Row A* (Page III-49)
  1450                                               # Column 3: Table III.5, Row Continental Temperate (Page III-51)
  1451                                           
  1452         2        445.0    222.5      3.0      c_1 = [2.93e-4, 5.25e-4, 1.59e-5]
  1453         2        160.0     80.0      1.1      c_2 = [3.78e-8, 1.57e-6, 1.56e-11]
  1454         2        207.0    103.5      1.4      c_3 = [1.02e-7, 4.70e-7, 2.77e-8]
  1455                                           
  1456         2        167.0     83.5      1.1      n_1 = [2.00, 1.97, 2.32]
  1457         2        144.0     72.0      1.0      n_2 = [2.88, 2.31, 4.08]
  1458         2        180.0     90.0      1.2      n_3 = [3.15, 2.90, 3.25]
  1459                                           
  1460         2        204.0    102.0      1.4      f_inf = [3.2, 5.4, 0.0]
  1461         2        153.0     76.5      1.0      f_m = [8.2, 10.0, 3.9]
  1462                                           
  1463         2        226.0    113.0      1.5      Z__db = [0, 0, 0]  # = [Y_0(90) Y_0(10) V(50)]
  1464         8        993.0    124.1      6.6      for i in range(3):
  1465         6       2984.0    497.3     19.9          f_2 = f_inf[i] + ((f_m[i] - f_inf[i]) * math.exp(-c_2[i] * pow(d_e__km, n_2[i])))
  1466         6       2875.0    479.2     19.1          Z__db[i] = (c_1[i] * pow(d_e__km, n_1[i]) - f_2) * math.exp(-c_3[i] * pow(d_e__km, n_3[i])) + f_2
  1467                                           
  1468         2        243.0    121.5      1.6      if p == 50:
  1469         2        355.0    177.5      2.4          Y_p__db = Z__db[2]
  1470                                               elif p > 50:
  1471                                                   z_90 = InverseComplementaryCumulativeDistributionFunction(90.0 / 100.0)
  1472                                                   z_p = InverseComplementaryCumulativeDistributionFunction(p / 100.0)
  1473                                                   c_p = z_p / z_90
  1474                                           
  1475                                                   Y = c_p * (-Z__db[0] * g_90)
  1476                                                   Y_p__db = Y + Z__db[2]
  1477                                               else:
  1478                                                   if p >= 10:
  1479                                                       z_10 = InverseComplementaryCumulativeDistributionFunction(10.0 / 100.0)
  1480                                                       z_p = InverseComplementaryCumulativeDistributionFunction(p / 100.0)
  1481                                                       c_p = z_p / z_10
  1482                                                   else:
  1483                                                       # Source for values p < 10: [15], Table 10, Page 34, Climate 6
  1484                                                       ps = [1, 2, 5, 10]
  1485                                                       c_ps = [1.9507, 1.7166, 1.3265, 1.0000]
  1486                                           
  1487                                                       # Simplified interpolation
  1488                                                       for i in range(len(ps) - 1):
  1489                                                           if ps[i] <= p < ps[i+1]:
  1490                                                               c_p = c_ps[i] + (c_ps[i+1] - c_ps[i]) * (p - ps[i]) / (ps[i+1] - ps[i])
  1491                                                               break
  1492                                                       else:
  1493                                                           c_p = c_ps[-1]
  1494                                           
  1495                                                   Y = c_p * (Z__db[1] * g_10)
  1496                                                   Y_p__db = Y + Z__db[2]
  1497                                           
  1498         2        351.0    175.5      2.3      Y_10__db = (Z__db[1] * g_10) + Z__db[2]  # [Eqn 14-20]
  1499         2        254.0    127.0      1.7      Y_eI__db = f_theta_h * Y_p__db  # [Eqn 14-21]
  1500         2        138.0     69.0      0.9      Y_eI_10__db = f_theta_h * Y_10__db  # [Eqn 14-22]
  1501                                           
  1502                                               # A_Y "is used to prevent available signal powers from exceeding levels expected for free-space propagation by an unrealistic
  1503                                               #      amount when the variability about L_b(50) is large and L_b(50) is near its free-space level" [ES-83-3, p3-4]
  1504                                           
  1505         2        306.0    153.0      2.0      A_YI = (A_T + Y_eI_10__db) - 3.0  # [Eqn 14-23]
  1506         2        491.0    245.5      3.3      A_Y = max(A_YI, 0)  # [Eqn 14-24]
  1507         2        237.0    118.5      1.6      Y_e__db = Y_eI__db - A_Y  # [Eqn 14-25]
  1508                                           
  1509                                               # For percentages less than 10%, do a correction check to,
  1510                                               #    "prevent available signal powers from exceeding levels expected from free-space levels
  1511                                               #     by unrealistic amounts" [Gierhart 1970]
  1512         2        268.0    134.0      1.8      if p < 10:
  1513                                                   c_Y = [-5.0, -4.5, -3.7, 0.0]
  1514                                                   P = [1, 2, 5, 10]  # Assuming this is data::P
  1515                                           
  1516                                                   # Simplified interpolation
  1517                                                   for i in range(len(P) - 1):
  1518                                                       if P[i] <= p < P[i+1]:
  1519                                                           c_Yi = c_Y[i] + (c_Y[i+1] - c_Y[i]) * (p - P[i]) / (P[i+1] - P[i])
  1520                                                           break
  1521                                                   else:
  1522                                                       c_Yi = c_Y[-1]
  1523                                           
  1524                                                   Y_e__db += A_T
  1525                                           
  1526                                                   if Y_e__db > -c_Yi:
  1527                                                       Y_e__db = -c_Yi
  1528                                           
  1529                                                   Y_e__db -= A_T
  1530                                           
  1531         2        221.0    110.5      1.5      return Y_e__db, A_Y

Total time: 7.908e-06 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: NakagamiRice at line 1656

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1656                                           def NakagamiRice(K_value, p_value):
  1657                                           
  1658         1       1741.0   1741.0     22.0      d_K = bisect.bisect_left(K, K_value)
  1659         1        454.0    454.0      5.7      d_p = bisect.bisect_left(P, p_value)
  1660                                           
  1661         1        164.0    164.0      2.1      if d_K == 0:  # K_value <= smallest K
  1662                                                   if d_p == 0:
  1663                                                       return NakagamiRiceCurves[0][0]
  1664                                                   else:
  1665                                                       return linear_interpolation(
  1666                                                           p_value, P[d_p - 1], NakagamiRiceCurves[0][d_p - 1],
  1667                                                           P[d_p], NakagamiRiceCurves[0][d_p]
  1668                                                       )
  1669         1        279.0    279.0      3.5      elif d_K == len(K):  # K_value > largest K
  1670                                                   if d_p == 0:
  1671                                                       return NakagamiRiceCurves[d_K - 1][0]
  1672                                                   else:
  1673                                                       return linear_interpolation(
  1674                                                           p_value, P[d_p - 1], NakagamiRiceCurves[d_K - 1][d_p - 1],
  1675                                                           P[d_p], NakagamiRiceCurves[d_K - 1][d_p]
  1676                                                       )
  1677                                               else:
  1678         1         98.0     98.0      1.2          if d_p == 0:
  1679                                                       return linear_interpolation(
  1680                                                           K_value, K[d_K - 1], NakagamiRiceCurves[d_K - 1][0],
  1681                                                           K[d_K], NakagamiRiceCurves[d_K][0]
  1682                                                       )
  1683                                                   else:
  1684         2       3231.0   1615.5     40.9              v1 = linear_interpolation(
  1685         1        351.0    351.0      4.4                  K_value, K[d_K - 1], NakagamiRiceCurves[d_K - 1][d_p],
  1686         1        163.0    163.0      2.1                  K[d_K], NakagamiRiceCurves[d_K][d_p]
  1687                                                       )
  1688         2        395.0    197.5      5.0              v2 = linear_interpolation(
  1689         1        275.0    275.0      3.5                  K_value, K[d_K - 1], NakagamiRiceCurves[d_K - 1][d_p - 1],
  1690         1        195.0    195.0      2.5                  K[d_K], NakagamiRiceCurves[d_K][d_p - 1]
  1691                                                       )
  1692         1        562.0    562.0      7.1              return linear_interpolation(p_value, P[d_p - 1], v2, P[d_p], v1)

Total time: 9.47e-07 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: CombineDistributions at line 1694

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1694                                           def CombineDistributions(A_M, A_p, B_M, B_p, p):
  1695         1         94.0     94.0      9.9      C_M = A_M + B_M
  1696                                           
  1697         1        122.0    122.0     12.9      Y_1 = A_p - A_M
  1698         1         72.0     72.0      7.6      Y_2 = B_p - B_M
  1699                                           
  1700         1        445.0    445.0     47.0      Y_3 = math.sqrt(Y_1**2 + Y_2**2)
  1701                                           
  1702         1        118.0    118.0     12.5      if p < 50:
  1703                                                   return C_M + Y_3
  1704                                               else:
  1705         1         96.0     96.0     10.1          return C_M - Y_3

Total time: 0 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: TranshorizonSearch at line 1731

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1731                                           def TranshorizonSearch(path, terminal_1, terminal_2, f_mhz, A_dML_db,  M_d, A_d0):
  1732                                               """
  1733                                               Implements Step 6 of Annex 2, Section 3 of Recommendation ITU-R P.528-5.
  1734                                           
  1735                                               Args:
  1736                                                   path: Structure containing propagation path parameters.
  1737                                                   terminal_1: Structure containing low terminal geometry parameters.
  1738                                                   terminal_2: Structure containing high terminal geometry parameters.
  1739                                                   f_mhz: Frequency in MHz.
  1740                                                   A_dML_db: Diffraction loss at d_ML in dB.
  1741                                           
  1742                                               Returns:
  1743                                                   M_d: Slope of the diffraction line.
  1744                                                   A_d0: Intercept of the diffraction line.
  1745                                                   d_crx_km: Final search distance in km.
  1746                                                   CASE: Case as defined in Step 6.5.
  1747                                               """
  1748                                           
  1749                                               CASE = CONST_MODE__SEARCH
  1750                                               k = 0
  1751                                           
  1752                                               tropo = TroposcatterParams()  # Assuming TroposcatterParams is a Python class
  1753                                               tropo.A_s__db = 0
  1754                                           
  1755                                               # Step 6.1. Initialize search parameters
  1756                                               d_search_km = np.array([path.d_ML__km + 3, path.d_ML__km + 2])
  1757                                               A_s_db = np.zeros(2)
  1758                                               M_s = 0
  1759                                           
  1760                                               SEARCH_LIMIT = 100
  1761                                           
  1762                                               for i_search in range(SEARCH_LIMIT):
  1763                                                   A_s_db[1] = A_s_db[0]
  1764                                           
  1765                                                   # Step 6.2
  1766                                                   troposcatter(path, terminal_1, terminal_2, d_search_km[0], f_mhz, tropo)
  1767                                                   A_s_db[0] = tropo.A_s__db
  1768                                           
  1769                                                   # if loss is less than 20 dB, the result is not within valid part of model
  1770                                                   if tropo.A_s__db < 20.0:
  1771                                                       d_search_km[1] = d_search_km[0]
  1772                                                       d_search_km[0] += 1
  1773                                                       continue
  1774                                           
  1775                                                   k += 1
  1776                                                   if k <= 1:  # need two points to draw a line and we don't have them both yet
  1777                                                       d_search_km[1] = d_search_km[0]
  1778                                                       d_search_km[0] += 1
  1779                                                       continue
  1780                                           
  1781                                                   # Step 6.3
  1782                                                   M_s = (A_s_db[0] - A_s_db[1]) / (d_search_km[0] - d_search_km[1])  # [Eqn 3-10]
  1783                                           
  1784                                                   if M_s <= M_d:
  1785                                                       d_crx_km = d_search_km[0]
  1786                                           
  1787                                                       # Step 6.6
  1788                                                       A_d__db = M_d * d_search_km[1] + A_d0  # [Eqn 3-11]
  1789                                           
  1790                                                       if A_s_db[1] >= A_d__db:
  1791                                                           CASE = 1  # CASE_1
  1792                                                       else:
  1793                                                           # Adjust the diffraction line to the troposcatter model
  1794                                                           M_d = (A_s_db[1] - A_dML_db) / (d_search_km[1] - path.d_ML__km)  # [Eqn 3-12]
  1795                                                           A_d0 = A_s_db[1] - (M_d * d_search_km[1])  # [Eqn 3-13]
  1796                                           
  1797                                                           CASE = 2  # CASE_2
  1798                                           
  1799                                                       return M_d, A_d0, d_crx_km, CASE
  1800                                           
  1801                                                   d_search_km[1] = d_search_km[0]
  1802                                                   d_search_km[0] += 1
  1803                                           
  1804                                               # M_s was always greater than M_d. Default to diffraction-only transhorizon model
  1805                                               CASE = 1  # CONST_MODE__DIFFRACTION
  1806                                               d_crx_km = d_search_km[1]
  1807                                           
  1808                                               return M_d, A_d0, d_crx_km, WARNING__DFRAC_TROPO_REGION

Total time: 0 s
File: /home/raulm/anatel/P528py/scalar/p528.py
Function: troposcatter at line 1811

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1811                                           def troposcatter(path, terminal_1, terminal_2, d_km, f_mhz, tropo):
  1812                                           
  1813                                               tropo.d_s__km = d_km - terminal_1.d_r__km - terminal_2.d_r__km
  1814                                           
  1815                                               if tropo.d_s__km <= 0.0:
  1816                                                   tropo.d_z__km = 0.0
  1817                                                   tropo.A_s__db = 0.0
  1818                                                   tropo.d_s__km = 0.0
  1819                                                   tropo.h_v__km = 0.0
  1820                                                   tropo.theta_s = 0.0
  1821                                                   tropo.theta_A = 0.0
  1822                                               else:
  1823                                                   # Compute the geometric parameters
  1824                                                   tropo.d_z__km = 0.5 * tropo.d_s__km
  1825                                           
  1826                                                   A_m = 1 / a_0__km
  1827                                                   dN = A_m - (1.0 / a_e__km)
  1828                                                   gamma_e__km = (N_s * 1e-6) / dN
  1829                                           
  1830                                                   z_a__km = 1.0 / (2 * a_e__km) * (tropo.d_z__km / 2) ** 2
  1831                                                   z_b__km = 1.0 / (2 * a_e__km) * tropo.d_z__km ** 2
  1832                                           
  1833                                                   Q_o = A_m - dN
  1834                                                   Q_a = A_m - dN / math.exp(min(35.0, z_a__km / gamma_e__km))
  1835                                                   Q_b = A_m - dN / math.exp(min(35.0, z_b__km / gamma_e__km))
  1836                                           
  1837                                                   Z_a__km = (7.0 * Q_o + 6.0 * Q_a - Q_b) * (tropo.d_z__km ** 2 / 96.0)
  1838                                                   Z_b__km = (Q_o + 2.0 * Q_a) * (tropo.d_z__km ** 2 / 6.0)
  1839                                           
  1840                                                   Q_A = A_m - dN / math.exp(min(35.0, Z_a__km / gamma_e__km))
  1841                                                   Q_B = A_m - dN / math.exp(min(35.0, Z_b__km / gamma_e__km))
  1842                                           
  1843                                                   tropo.h_v__km = (Q_o + 2.0 * Q_A) * (tropo.d_z__km ** 2 / 6.0)
  1844                                                   tropo.theta_A = (Q_o + 4.0 * Q_A + Q_B) * tropo.d_z__km / 6.0
  1845                                                   tropo.theta_s = 2 * tropo.theta_A
  1846                                           
  1847                                                   # Compute the scattering efficiency term
  1848                                                   epsilon_1 = 5.67e-6 * N_s ** 2 - 0.00232 * N_s + 0.031
  1849                                                   epsilon_2 = 0.0002 * N_s ** 2 - 0.06 * N_s + 6.6
  1850                                           
  1851                                                   gamma = 0.1424 * (1.0 + epsilon_1 / math.exp(min(35.0, (tropo.h_v__km / 4.0) ** 6)))
  1852                                                   S_e__db = 83.1 - epsilon_2 / (1.0 + 0.07716 * tropo.h_v__km ** 2) + 20 * math.log10((0.1424 / gamma) ** 2 * math.exp(gamma * tropo.h_v__km))
  1853                                           
  1854                                                   # Compute the scattering volume term
  1855                                                   X_A1__km2 = (terminal_1.h_e__km ** 2) + 4.0 * (a_e__km + terminal_1.h_e__km) * a_e__km * math.sin(terminal_1.d_r__km / (2 * a_e__km)) ** 2
  1856                                                   X_A2__km2 = (terminal_2.h_e__km ** 2) + 4.0 * (a_e__km + terminal_2.h_e__km) * a_e__km * math.sin(terminal_2.d_r__km / (2 * a_e__km)) ** 2
  1857                                           
  1858                                                   ell_1__km = math.sqrt(X_A1__km2) + tropo.d_z__km
  1859                                                   ell_2__km = math.sqrt(X_A2__km2) + tropo.d_z__km
  1860                                                   ell__km = ell_1__km + ell_2__km
  1861                                           
  1862                                                   s = (ell_1__km - ell_2__km) / ell__km
  1863                                                   eta = gamma * tropo.theta_s * ell__km / 2
  1864                                           
  1865                                                   kappa = f_mhz / 0.0477
  1866                                           
  1867                                                   rho_1__km = 2.0 * kappa * tropo.theta_s * terminal_1.h_e__km
  1868                                                   rho_2__km = 2.0 * kappa * tropo.theta_s * terminal_2.h_e__km
  1869                                           
  1870                                                   SQRT2 = math.sqrt(2)
  1871                                           
  1872                                                   A = (1 - s ** 2) ** 2
  1873                                           
  1874                                                   X_v1 = (1 + s) ** 2 * eta
  1875                                                   X_v2 = (1 - s) ** 2 * eta
  1876                                           
  1877                                                   q_1 = X_v1 ** 2 + rho_1__km ** 2
  1878                                                   q_2 = X_v2 ** 2 + rho_2__km ** 2
  1879                                           
  1880                                                   B_s = 6 + 8 * s ** 2 + 8 * (1.0 - s) * X_v1 ** 2 * rho_1__km ** 2 / q_1 ** 2 + 8 * (1.0 + s) * X_v2 ** 2 * rho_2__km ** 2 / q_2 ** 2 + 2 * (1.0 - s ** 2) * (1 + 2 * X_v1 ** 2 / q_1) * (1 + 2 * X_v2 ** 2 / q_2)
  1881                                           
  1882                                                   C_s = 12 * ((rho_1__km + SQRT2) / rho_1__km) ** 2 * ((rho_2__km + SQRT2) / rho_2__km) ** 2 * (rho_1__km + rho_2__km) / (rho_1__km + rho_2__km + 2 * SQRT2)
  1883                                           
  1884                                                   temp = (A * eta ** 2 + B_s * eta) * q_1 * q_2 / (rho_1__km ** 2 * rho_2__km ** 2)
  1885                                           
  1886                                                   S_v__db = 10 * math.log10(temp + C_s)
  1887                                           
  1888                                                   tropo.A_s__db = S_e__db + S_v__db + 10.0 * math.log10(kappa * tropo.theta_s ** 3 / ell__km)

Total time: 0.0116444 s
File: /home/raulm/anatel/P528py/scalar/tests/line_profiler_test.py
Function: run_tests at line 10

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    10                                           def run_tests():
    11         1   11644330.0    1e+07    100.0      result = P528(0, 2, 3, 1000, 0, 50)
    12         1         46.0     46.0      0.0      return result

